rolname,query,calls,total_time,min_time,max_time,mean_time,avg_rows
postgres,"SELECT 
        a.asset_id,
        a.company_name,
        a.ticker,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $3), $4) as total_volume,
        COUNT(t.transaction_id) as trade_count,
        COUNT(DISTINCT f.member_id) as politician_count,
        MAX(t.transaction_date) as last_traded
      FROM ""Assets"" a
      LEFT JOIN ""Transactions"" t ON a.asset_id = t.asset_id
      LEFT JOIN ""Filings"" f ON t.filing_id = f.filing_id
      GROUP BY a.asset_id, a.company_name, a.ticker
      HAVING COUNT(t.transaction_id) > $5
      ORDER BY total_volume DESC
      LIMIT $1 OFFSET $2",16,1795.054264,91.909705,163.598241,112.1908915,50
postgres,"with tables as (SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      table_id,
      jsonb_agg(_pk.*) as primary_keys
    from (
      select
        n.nspname as schema,
        c.relname as table_name,
        a.attname as name,
        c.oid :: int8 as table_id
      from
        pg_index i,
        pg_class c,
        pg_attribute a,
        pg_namespace n
      where
        i.indrelid = c.oid
        and c.relnamespace = n.oid
        and a.attrelid = c.oid
        and a.attnum = any (i.indkey)
        and i.indisprimary
    ) as _pk
    group by table_id
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = $12
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ($13, $14)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $15)
    OR has_table_privilege(
      c.oid,
      $16
    )
    OR has_any_column_privilege(c.oid, $17)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
)
  , columns as (-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || $18 || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE $19
  END AS default_value,
  CASE
    WHEN t.typtype = $20 THEN CASE
      WHEN bt.typelem <> $21 :: oid
      AND bt.typlen = $22 THEN $23
      WHEN nbt.nspname = $24 THEN format_type(t.typbasetype, $25)
      ELSE $26
    END
    ELSE CASE
      WHEN t.typelem <> $27 :: oid
      AND t.typlen = $28 THEN $29
      WHEN nt.nspname = $30 THEN format_type(a.atttypid, $31)
      ELSE $32
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ($33, $34) AS is_identity,
  CASE
    a.attidentity
    WHEN $35 THEN $36
    WHEN $37 THEN $38
    ELSE $39
  END AS identity_generation,
  a.attgenerated IN ($40) AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = $41 AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ($42, $43)
    OR c.relkind IN ($44, $45) AND pg_column_is_updatable(c.oid, a.attnum, $46)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS ""check"",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = $47
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$48] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = $49 AND cardinality(conkey) = $50
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[$51] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, $52),
        $53,
        length(pg_get_constraintdef(pg_constraint.oid, $54)) - $55
      ) AS ""definition""
    FROM pg_constraint
    WHERE contype = $56 AND cardinality(conkey) = $57
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > $58
  AND NOT a.attisdropped
  AND (c.relkind IN ($59, $60, $61, $62, $63))
  AND (
    pg_has_role(c.relowner, $64)
    OR has_column_privilege(
      c.oid,
      a.attnum,
      $65
    )
  )
)
select
  *
  , 
COALESCE(
  (
    SELECT
      array_agg(row_to_json(columns)) FILTER (WHERE columns.table_id = tables.id)
    FROM
      columns
  ),
  $66
) AS columns
from tables where schema IN ($67)",2,197.630294,82.441194,115.1891,98.815147,7
postgres,"SELECT
  e.name,
  n.nspname AS schema,
  e.default_version,
  x.extversion AS installed_version,
  e.comment
FROM
  pg_available_extensions() e(name, default_version, comment)
  LEFT JOIN pg_extension x ON e.name = x.extname
  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid",31,2253.843174,1.966571,194.268913,72.704618516129,76
postgres,"SELECT 
        m.party,
        COUNT(DISTINCT m.member_id) as member_count,
        COUNT(t.transaction_id) as total_trades,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $1), $2) as total_volume
      FROM ""Members"" m
      LEFT JOIN ""Filings"" f ON m.member_id = f.member_id
      LEFT JOIN ""Transactions"" t ON f.filing_id = t.filing_id
      WHERE m.party IS NOT NULL
      GROUP BY m.party
      HAVING COUNT(t.transaction_id) > $3
      ORDER BY total_volume DESC",9,361.06715,37.632661,43.254007,40.1185722222222,3
postgres,"SELECT 
        m.member_id,
        m.name,
        m.photo_url,
        m.party,
        m.state,
        m.chamber,
        COUNT(t.transaction_id) as trade_count,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $1), $2) as total_volume
      FROM ""Members"" m
      LEFT JOIN ""Filings"" f ON m.member_id = f.member_id
      LEFT JOIN ""Transactions"" t ON f.filing_id = t.filing_id
      GROUP BY m.member_id, m.name, m.photo_url, m.party, m.state, m.chamber
      HAVING COUNT(t.transaction_id) > $3
      ORDER BY trade_count DESC
      LIMIT $4",86,3365.953155,30.662188,195.309381,39.1389901744186,5
postgres,"with tables as (SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = $1 THEN $2
    WHEN c.relreplident = $3 THEN $4
    WHEN c.relreplident = $5 THEN $6
    ELSE $7
  END AS replica_identity,
  pg_total_relation_size(format($8, nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format($9, nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, $10) as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    $11
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      table_id,
      jsonb_agg(_pk.*) as primary_keys
    from (
      select
        n.nspname as schema,
        c.relname as table_name,
        a.attname as name,
        c.oid :: int8 as table_id
      from
        pg_index i,
        pg_class c,
        pg_attribute a,
        pg_namespace n
      where
        i.indrelid = c.oid
        and c.relnamespace = n.oid
        and a.attrelid = c.oid
        and a.attnum = any (i.indkey)
        and i.indisprimary
    ) as _pk
    group by table_id
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = $12
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ($13, $14)
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, $15)
    OR has_table_privilege(
      c.oid,
      $16
    )
    OR has_any_column_privilege(c.oid, $17)
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
)
  
select
  *
  
from tables where schema IN ($18)",3,116.892024,19.448699,60.492611,38.964008,7
postgres,"SELECT 
        m.state,
        COUNT(DISTINCT m.member_id) as member_count,
        COUNT(t.transaction_id) as total_trades,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $1), $2) as total_volume
      FROM ""Members"" m
      LEFT JOIN ""Filings"" f ON m.member_id = f.member_id
      LEFT JOIN ""Transactions"" t ON f.filing_id = t.filing_id
      WHERE m.state IS NOT NULL
      GROUP BY m.state
      HAVING COUNT(t.transaction_id) > $3
      ORDER BY total_volume DESC
      LIMIT $4",9,332.608481,34.218246,39.477994,36.9564978888889,10
postgres,"SELECT 
        m.member_id,
        m.name,
        m.photo_url,
        m.party,
        m.state,
        m.chamber,
        COUNT(t.transaction_id) as trade_count,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $1), $2) as total_volume,
        MAX(t.transaction_date) as latest_trade_date
      FROM ""Members"" m
      LEFT JOIN ""Filings"" f ON m.member_id = f.member_id
      LEFT JOIN ""Transactions"" t ON f.filing_id = t.filing_id
      GROUP BY m.member_id, m.name, m.photo_url, m.party, m.state, m.chamber
      HAVING COUNT(t.transaction_id) > $3
      ORDER BY total_volume DESC",9,306.833231,32.297112,35.465036,34.0925812222222,317
postgres,"SELECT 
        a.ticker,
        a.company_name,
        COUNT(t.transaction_id) as trade_count,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $1), $2) as total_volume
      FROM ""Assets"" a
      LEFT JOIN ""Transactions"" t ON a.asset_id = t.asset_id
      WHERE a.ticker IS NOT NULL
      GROUP BY a.asset_id, a.ticker, a.company_name
      HAVING COUNT(t.transaction_id) > $3
      ORDER BY trade_count DESC
      LIMIT $4",66,2156.637766,21.41731,136.593344,32.6763297878788,5
postgres,"with _base_query as (select * from public.""API_Requests"" order by ""API_Requests"".request_id asc nulls last limit $1 offset $2)
  select request_id,filing_id,case
        when octet_length(doc_id::text) > $3 
        then left(doc_id::text, $4) || $5
        else doc_id::text
      end as doc_id,case
        when octet_length(generation_id::text) > $6 
        then left(generation_id::text, $7) || $8
        else generation_id::text
      end as generation_id,case
        when octet_length(model::text) > $9 
        then left(model::text, $10) || $11
        else model::text
      end as model,max_tokens,text_length,approx_tokens,case
        when octet_length(finish_reason::text) > $12 
        then left(finish_reason::text, $13) || $14
        else finish_reason::text
      end as finish_reason,response_status,case
        when octet_length(error_message::text) > $15 
        then left(error_message::text, $16) || $17
        else error_message::text
      end as error_message,case
        when octet_length(pdf_link::text) > $18 
        then left(pdf_link::text, $19) || $20
        else pdf_link::text
      end as pdf_link,case
        when octet_length(raw_text::text) > $21 
        then left(raw_text::text, $22) || $23
        else raw_text::text
      end as raw_text,case
        when octet_length(llm_response::text) > $24 
        then left(llm_response::text, $25) || $26
        else llm_response::text
      end as llm_response,created_at from _base_query",1,32.386439,32.386439,32.386439,32.386439,100
postgres,"SELECT 
        a.asset_id,
        a.ticker,
        a.company_name,
        COUNT(t.transaction_id) as trade_count,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $1), $2) as total_volume
      FROM ""Assets"" a
      LEFT JOIN ""Transactions"" t ON a.asset_id = t.asset_id
      WHERE a.ticker IS NOT NULL
      GROUP BY a.asset_id, a.ticker, a.company_name
      HAVING COUNT(t.transaction_id) > $3
      ORDER BY trade_count DESC
      LIMIT $4",20,521.819305,22.00574,32.581525,26.09096525,5
postgres,"SELECT ""public"".""Transactions"".""transaction_id"", ""public"".""Transactions"".""filing_id"", ""public"".""Transactions"".""asset_id"", ""public"".""Transactions"".""owner_code"", ""public"".""Transactions"".""transaction_type"", ""public"".""Transactions"".""transaction_date"", ""public"".""Transactions"".""amount_range_low"", ""public"".""Transactions"".""amount_range_high"", ""public"".""Transactions"".""raw_llm_csv_line"", ""public"".""Transactions"".""created_at"" FROM ""public"".""Transactions"" WHERE ""public"".""Transactions"".""filing_id"" IN ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$70,$71,$72,$73,$74,$75,$76,$77,$78,$79,$80,$81,$82,$83,$84,$85,$86,$87,$88,$89,$90,$91,$92,$93,$94,$95,$96,$97,$98,$99,$100,$101,$102,$103,$104,$105,$106,$107,$108,$109,$110,$111,$112,$113,$114,$115,$116,$117,$118,$119,$120,$121,$122,$123,$124,$125,$126,$127,$128,$129,$130,$131,$132,$133,$134,$135,$136,$137,$138,$139,$140,$141,$142,$143,$144,$145,$146,$147,$148,$149,$150,$151,$152,$153,$154,$155,$156,$157,$158,$159,$160,$161,$162,$163,$164,$165,$166,$167,$168,$169,$170,$171,$172,$173,$174,$175,$176,$177,$178,$179,$180,$181,$182,$183,$184,$185,$186,$187,$188,$189,$190,$191,$192,$193,$194,$195,$196,$197,$198,$199,$200,$201,$202,$203,$204,$205,$206) OFFSET $207",1,23.828277,23.828277,23.828277,23.828277,1101
postgres,"select (select count(*) from public.""API_Requests""), $1 as is_estimate",1,23.534653,23.534653,23.534653,23.534653,1
postgres,"SELECT 
        a.asset_id,
        a.ticker,
        a.company_name,
        COUNT(t.transaction_id) as trade_count,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $6), $7) as total_volume
      FROM ""Assets"" a
      LEFT JOIN ""Transactions"" t ON a.asset_id = t.asset_id
      WHERE (a.ticker ILIKE $8 || $1 || $9 OR a.company_name ILIKE $10 || $2 || $11)
      GROUP BY a.asset_id, a.ticker, a.company_name
      HAVING COUNT(t.transaction_id) > $12
      ORDER BY 
        CASE 
          WHEN a.ticker LIKE $3 || $13 THEN $14
          WHEN a.company_name LIKE $4 || $15 THEN $16
          ELSE $17
        END,
        trade_count DESC
      LIMIT $5",8,149.219109,14.479712,31.224652,18.652388625,3
postgres,"SELECT 
        a.asset_id,
        a.company_name,
        a.ticker,
        COALESCE(SUM((t.amount_range_low + t.amount_range_high) / $6), $7) as total_volume,
        COUNT(t.transaction_id) as trade_count,
        COUNT(DISTINCT f.member_id) as politician_count,
        MAX(t.transaction_date) as last_traded
      FROM ""Assets"" a
      LEFT JOIN ""Transactions"" t ON a.asset_id = t.asset_id
      LEFT JOIN ""Filings"" f ON t.filing_id = f.filing_id
      WHERE (a.ticker ILIKE $8 || $1 || $9 OR a.company_name ILIKE $10 || $2 || $11)
      GROUP BY a.asset_id, a.company_name, a.ticker
      HAVING COUNT(t.transaction_id) > $12
      ORDER BY 
        CASE 
          WHEN a.ticker LIKE $3 || $13 THEN $14
          WHEN a.company_name LIKE $4 || $15 THEN $16
          ELSE $17
        END,
        total_volume DESC
      LIMIT $5",9,160.579276,14.162629,38.778066,17.8421417777778,10
supabase_admin,"SELECT t.oid, t.typname, t.typsend, t.typreceive, t.typoutput, t.typinput,
       coalesce(d.typelem, t.typelem), coalesce(r.rngsubtype, $1), ARRAY (
  SELECT a.atttypid
  FROM pg_attribute AS a
  WHERE a.attrelid = t.typrelid AND a.attnum > $2 AND NOT a.attisdropped
  ORDER BY a.attnum
)

FROM pg_type AS t
LEFT JOIN pg_type AS d ON t.typbasetype = d.oid
LEFT JOIN pg_range AS r ON r.rngtypid = t.oid OR r.rngmultitypid = t.oid OR (t.typbasetype <> $3 AND r.rngtypid = t.typbasetype)
WHERE (t.typrelid = $4)
AND (t.typelem = $5 OR NOT EXISTS (SELECT $6 FROM pg_catalog.pg_type s WHERE s.typrelid != $7 AND s.oid = t.typelem))",2,28.80518,7.328477,21.476703,14.40259,209
postgres,"SELECT COALESCE(SUM((amount_range_low + amount_range_high) / $1), $2) as total_volume
        FROM ""Transactions""",86,973.948139,6.348113,149.216107,11.3249783604651,1
postgres,"SELECT ""public"".""Transactions"".""transaction_id"", ""public"".""Transactions"".""filing_id"", ""public"".""Transactions"".""asset_id"", ""public"".""Transactions"".""owner_code"", ""public"".""Transactions"".""transaction_type"", ""public"".""Transactions"".""transaction_date"", ""public"".""Transactions"".""amount_range_low"", ""public"".""Transactions"".""amount_range_high"", ""public"".""Transactions"".""raw_llm_csv_line"", ""public"".""Transactions"".""created_at"" FROM ""public"".""Transactions"" WHERE ""public"".""Transactions"".""filing_id"" IN ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53,$54,$55,$56,$57,$58,$59,$60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$70,$71,$72,$73,$74,$75,$76,$77,$78,$79) OFFSET $80",2,21.318969,1.300004,20.018965,10.6594845,857
postgres,"SELECT COALESCE(SUM((amount_range_low + amount_range_high) / $1), $2) as total_volume
        FROM ""Transactions""",16,117.627441,6.51187,9.133483,7.3517150625,1
postgres,"SELECT COUNT(*) AS ""_count._all"" FROM (SELECT ""public"".""Transactions"".""transaction_id"" FROM ""public"".""Transactions"" WHERE $2=$3 OFFSET $1) AS ""sub""",102,746.428845,4.403441,56.381182,7.31792985294118,1